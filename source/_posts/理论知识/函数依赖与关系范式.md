---
title: 函数依赖与关系范式
date: 2024-05-10 10:57:51
categories: 理论知识
---

# 基本概念
## 函数依赖
- 基础概念
若对于给定的X, 必然有唯一确定的Y, 则称**X决定Y**, 即**Y依赖于X**，记作: X->Y
<!-- more -->
- 完全依赖/部分依赖
    - 若X->Y, 并且任意X子集X’, 均有X’->Y，则Y完全依赖X，X-f->Y
    - 若X->Y, 但不是X所有子集均决定Y, 则Y部分依赖X, X-p->Y

- 传递依赖
X->Y, Y->Z, 则X->Z

> [e.g.] 以SDC(SNO,DEPT,MNAME,CNAME,GRADE)为例
> - ∵ sno->dept && dept->mname ∴ sno->mname	// 传递依赖
> - (sno,cname)->grade				// 完全依赖
> - (sno,cname,mname)->grade        // 部分依赖



## 常用推导规则
- 合并规则：由X->Y,X->Z,有X->YZ
  
    > XX->XY, XY->ZY, ∴XX->YZ,X->YZ
    
- 伪传递规则：由X->Y, WY->Z,有XW->Z
  
    > XW->WY, WY->Z, ∴XW->Z
    
- 分解规则：由X->Y, Z属于Y, 有X->Z

## 函数依赖的种类
- 平凡依赖，非平凡依赖，完全依赖，部分依赖，传递依赖

## 范式的种类
- 1NF: 必须满足的范式，所有属性不可再分
- 2NF: 在1NF的基础上，所有非主属性都**完全依赖**于主属性
- 3NF: 在2NF的基础上，不存在“**非主属性**对**码**的传递依赖”
- BCNF：在3NF的基础上，不存在“**主属性**对**码**的传递依赖”
- 4NF：在BCNF的基础上，对于每一个多值依赖X->->Y, X都含有码

## 规范化的原因
- 数据冗余
- 插入异常
- 修改异常
- 删除异常


## 并不是规范化程度越高的关系就越优
- 规范化程度越高，往往意味着**查询**操作需要额外的**连接** / **计算**操作，消耗较大
    > [e.g.] 学生成绩(学号,英语,数学,语文,平均分)
        > - 存在函数依赖：学号->英语，学号->数学，学号->语文，学号->平均分，(英语, 数学, 语文)->平均分
        > - 显然有**学号->(英语,数学,语文)->平均分**，所以该关系模式中存在传递函数信赖，是2NF关系，不满足3NF
        > - 虽然平均成绩可以由其他属性推算出来，但如果应用中需要经常查询学生的平均成绩，为提高效率，仍然可保留该冗余数据，对关系模式不再做进一步分解
    
- 一般而言，2NF, 3NF是比较合适的




# 判断关系模式属于第几范式
- 根据1NF, 2NF, 3NF的定义来进行判断
    > - 每个属性都不可再细分->1NF
    > - 非主属性都完全依赖于主属性->2NF
    > - 无传递依赖->3NF



# 判断候选码
- 如果有属性**不在**函数依赖集中**出现**，那么它必须包含在候选码中
- 如果有属性**只**在函数依赖集的**右边**出现，那么它必须**不在**候选码中
- 如果有属性**只**在函数依赖集的**左边**出现，则该属性一定**包含**在候选码中
- 如果有属性或属性组能唯一标识元组，则它就是候选码
  
    > 通过函数依赖推导出，某属性或属性组，能决定所有属性

- [e.g.] `r<U,f>, U=(A,B,C,G,H,I). f={A->B, A->C, CG->H, CG->I, B->H}`

  > 1. A,CG只在依赖集左边出现，所以A,CG在候选码集合中
  > 2. H,I只在右边出现，一定不在候选码中
  > 3. (A,C,G)->(A,C,G,B,H,I)，检查确认无法再化简，所以候选码为(A,C,G)

- [e.g.] `sdc(sno,dept,mname,cname,grade)`找出该关系的主码

  > 1. **(sno,cname)->grade**
  > 2. sno->dept ∴ **(sno,cname)->dept**
  > 3. dept->mname ∴sno->mname ∴ **(sno,cname)->mname**
  > 4. 综上，**(sno,cname)->(sno,cname,grade,dept,mname)**
  > 5. 所以(sno,cname)是主键




# 求最小函数依赖集合
## 对于“最小”理解
- 对于一个关系模式r<U,f>而言，可以写出无数个f
  
    > e.g. r<U,f>, U=(A,B,C). f={A->B, A->C, A->BC}
- 但是所有f中，只有一个f是最小的，由这个f可以推导出其余所有f
  
    > e.g. f={A->B, A->C, A->BC}中A->BC可以由其他部分推导得出，所以这个f不是最小的

## 定义
- 如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集，亦称为最小依赖集或最小覆盖
    - F中任一函数依赖**右部**仅含有**一个**属性
    - F中**不存在**这样的函数依赖 X->A，使得F与F-{X->A} 等价
    - F中**不存在**这样的函数依赖X->A，X有真子集Z使得F-{X->A}⋃{Z->A} 与F等价
      
        > F中不存在这样的函数依赖：假设函数依赖集中存在AB->Y，现对该依赖的左部进行化简，即删除A，得B->Y；或删除B，得A->Y，若经过化简后的函数依赖集与没有化简前的函数依赖集等价，那么这样的函数依赖是不允许存在的

## 算法
1. 先利用函数依赖的分解性，将函数依赖集中**右部不为单个属性**的分解为单属性
2. 对于经过第1步筛选后的函数依赖集F中的每一个函数依赖X->A，进行以下操作：
    1. 将X->A从函数依赖中尝试剔除
    2. 基于剔除后的函数依赖，计算属性X的闭包，看其是否包含了A，若是，则该函数依赖是多余的(这里体现出前面说的等价，因为如果基于化简后的函数依赖依赖，计算X的闭包依然包含A，则说明A可以由其他依赖推出，X->A不是必须的)，可以删除，否则不能删除
3. 对于经过第2步筛选后的函数依赖集f中每个**左部不为单个属性**的函数依赖AB->Y，进行以下操作：
    1. 去除A，得B->Y，分别计算去除前后的闭包，则说明它们是等价的，A可以去除；如果不相等，则A不能去除
    2. 去除B，得A->Y，分别计算去除前后的闭包，则说明它们是等价的，B可以去除；如果不相等，则B不能去除

## 例题
- [e.g.] 关系模式R(U,F)中，U={A,B,C,D,E,G}，F={B->D,DG->C,BD->E,AG->B,ADG->BC}；求F的最小函数依赖集

> 1. 首先根据函数依赖的分解性，对F进行第一次筛选
>
>      ADG->BC拆解成ADG->B, ADG->C
>
>      得新函数依赖集：F = {B->D,DG->C,BD->E,AG->B,ADG->B,ADG->C}
>
> 2. 筛选多余的函数依赖
    1. 去除B->D，得F'={DG->C,BD->E,AG->B,ADG->B,ADG->C}
      `闭包(B)`={B}，不包含D，故B->D不删除
    2. 去除DG->C，得F'={B->D,BD->E,AG->B,ADG->B,ADG->C}
       `闭包(DG)`={D,G}，不包含C，故DG->C不删除
    3. 去除BD->E，得F'={B->D,DG->C,AG->B,ADG->B,ADG->C}
       `闭包(BD)`= {B,D}，不包含E，故BD->E不删除
    4. 去除AG->B，得F'={B->D,DG->C,BD->E,ADG->B,ADG->C}
      `闭包(AG)`= {A,G}，不包含B，故AG->B不删除
    5. 去除ADG->B，得F'={B->D,DG->C,BD->E,AG->B,ADG->C}
      `闭包(ADG)`={A,D,G,C,B,E}，包含B，故ADG->B**去除**
    6. 去除ADG->C，得F'={B->D,DG->C,BD->E,AG->B,ADG->B}
      `闭包(ADG)`={A,D,G,C,B,E}，包含C，故ADG->C**去除**
> 
>    经过第二部筛选后，函数依赖集F={B->D, DG->C, BD->E, AG->B}
>
> 3. 化简函数依赖左侧不为单个属性的函数依赖
>
>       1. DG->C
>
>          1. 去除D，得G->C，得函数依赖集F1 = {B->D,G->C,BD->E,AG->B}
>          	
>             `原闭包(G)={G}`，`新闭包(G)={G,C}` 二者并不相同，所以D不去除。
>          	
>          2. 去除G，得D->C，得函数依赖集F1 = {B->D,D->C,BD->E,AG->B}
>             `原闭包(D)={D}`, `新闭包(D)={D,C}` 二者并不相同，所以G不去除。
>
>          3. 综上，DG->C，已是最简。
>
>       2. BD->E
>
>          1. 去除B，得D->E，得函数依赖集F1 = {B->D,DG->C,D->E,AG->B}
>             `原闭包(D)={D}`, `新闭包(D)={D,E}` 二者并不相同，所以B不去除
>          2. 去除D，得B->E，得函数依赖集F1 = {B->D,DG->C,B->E,AG->B}
>             `原闭包(B)={B,D,E}`, `新闭包(B)={B,D,E}`  二者相同，所以**D可以去除**
>          3. 综上，**BD->E可化简为B->E**
>
>       3. AG->B
>
>          1. 去除A，得G->B，得函数依赖集F1 = {B->D,DG->C,B->E,G->B}
>             `原闭包(G)={G}`, `新闭包(G)={G,B}` 二者不相同，所以A不可去除
>          2. 去除G，得A->B，得函数依赖F1 = {B->D,DG->C,B->E,A->B}
>             `原闭包(A)={A}`, `新闭包(A)={A,B,D,E}` 二者并不相同，所以G不可去除。
>          3. 综上，AG->B，已是最简
>
> 综上，R的最小函数依赖集为F = {B->D, DG->C, B->E, AG->B}



# 分解关系模式，使其满足2NF
## 算法
> 1. 确定模式R(U)的主键W
> 2. 看是否存在函数依赖 X->Z（X是W的真子集，Z是非主属性）如果存在，则模式R可以进行分解；否则就不能分解
> 3. 若可以，则分解为R1(X,Z) 和 R2(U-Z)
> 4. 继续对R1和R2重复上述步骤


## 例题
- [e.g.] 给出 R(sno, sname, dept, dept_head, course, grade)，满足1NF，分解为2NF
    > 1. 确认R的主键：(sno, course)
    > 2. 找出主键中的部分依赖：sno->(sname,dept,dept_head)
    > 3. 将R分解为`R1(sno,sname,dept,dept_head)`, `R2(sno,course,grade)`
    > 4. 无法再细分，故满足2NF



# 分解关系模式，使其满足3NF
## 算法
> 1. 确定模式R(U)的主键 W
> 2. 看是否存在函数依赖 X->Z（X,Z均为非主属性，且X不属于Z）。如果存在，则有W->X->Z传递依赖，可分解
> 3. 若可以，则分解为R1(X,Z) 和 R2(U-Z)
> 4. 继续对R1和R2重复上述步骤

## 例题
- [e.g.] 将`R1(sno,sname,dept,dept_head)`, `R2(sno,course,grade)`分解为3NF
    > 1. R2中不存在传递依赖，R1中存在sno->dept->dept_head的传递依赖
    > 2. R1分解为`R11(sno,sname,dept)`, `R12(dept,dept_head)`
    > 3. 不可再分，结束，满足3NF

