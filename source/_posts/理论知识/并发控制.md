---
title: 并发控制
date: 2024-05-12
categories: 理论知识
---

# 锁
## 排他锁 (X锁，写锁)
若事务T对数据A加X锁
- 则只允许T读取和修改A
- 其他事务不能再对A加任何锁，直到T释放A上的X锁
- 保证了在T释放A上X锁之前其他事务不能再读取和修改A
<!-- more -->

## 共享锁 (S锁，读锁)
若事务T对数据A加S锁
- 则事务T只可读A，但不能修改A
- 其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁
- 保证了在T释放A上S锁之前其它事务可以读A，但不能修改A


## 死锁情况
1. 诊断 		超时法
2. 解除 		进行事务回滚，释放锁


# 并发造成的数据不一致问题

## 丢失修改（lost update）
> 两个事务T1和T2读入同一个数据并修改，T2提交的结果破坏了T1提交的结果，导致了T1的修改被丢失

## 不可重复读（non-repeatable read）
> 事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取的结果

## 读“脏”数据（dirty read）
> 当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据）


# 封锁协议
## 一级封锁协议
- 事务T在修改数据A之前必须先对其加X锁，直到该事务结束才释放X锁
- 防丢失修改

## 二级封锁协议
- 一级封锁协议之上, 事务T在读取数据A前必须先对其加S锁, 读完后立即释放S锁
- 防丢失修改，防读“脏”数据

## 三级封锁协议
- 一级封锁协议之上,事务T在读取数据A前必须先对其加S锁,直到该事务结束才释放S锁
- 防丢失修改，防读“脏”数据，防不可重复读

## 两段锁协议(2PL)
- 一个事务和锁相关的操作只有2段
1) 只获得锁，不释放锁
2) 只释放锁，不获得锁


- 事务在释放一个锁后，就不会再获得锁
- 2PL是**可串行化调度**的充分条件
- 2PL可能会出现死锁